---
title: Основы командного интерфейса
---

Поскольку не исключена вероятность, что эту книгу будут читать и совсем начинающие применители Linux'а вообще, тех, для кого `Mint` оказался первым дистрибутивом этой операционной системы, в этом очерке будут даны некоторые общие сведения об интерфейсе командной строки (`CLI` — Command Line Interface). Тем более, что это потребуется уже ближайшее время, в очерках, посвящённых управлению пакетами.

### Введение в CLI

`CLI` представляет собой базу, для которой GUI всякого рода являют лишь оболочку. Всякое действие в linux-системе может быть выполнено прямой командной директивой. И его же можно осуществить путем манипулирования объектами. Например, копирование файлов выполняется соответствующей командой — `cp`, это первый способ. Но его же можно осуществить перетаскиванием мышью объекта, представляющего наш файл зрительно, из того места, где он находился ранее, туда, где мы хотим видеть его копию, а это уже второй способ.

То есть манипуляция объектами в `GUI` — это обычно более или менее опосредованное выполнение соответствующих данному действию команд. Почему основные навыки работы с `CLI` не помешают даже тому пользователю, который не вылезает из графической среды. Ибо сфера применения `CLI` не ограничивается «голой» консолью. Он же используется в эмуляторах терминала в графическом режиме оконной среды `X`. Более того, в настоящее время это основная среда для применения командного интерфейса — к текстовой консоли обычно обращаются только в аварийных ситуациях.

`CLI` в большинстве случаев обеспечивается классом программ, именуемых командными интерпретаторами, командными процессорами, командными оболочками или по простому шеллами (`shell`).

Как легко догадаться по одному из определений, кроме предоставления пользовательского интерфейса, шеллы выполняют и вторую функцию — служат интерпретаторами собственных языков программирования. На этом основывается классификация шеллов — они разделяются на две группы, обычно именуемые `Bourne-shell` совместимые и `C-shell` совместимые. В силу ряда причин в качестве стандарта принята одна из оболочек первой группы — так называемый `POSIX-шелл`. Правда, он представляет собой чистую абстракцию, однако большинство используемых в Unix'ах оболочек с этим стандартом совместимы. А системная оболочка `Mint`, `Dash`, довольно точно воспроизводит и его функциональность. И потому все примеры, иллюстрирующие принципиальные вопросы CLI, будут базироваться на наиболее используемых командах, построенных в соответствие с правилами POSIX-шелла.

### Командная строка

Основой командного интерфейса является командная строка, начинающаяся с приглашения для ввода. Далее он будет обозначаться милым сердцу россиянина символом длинного зеленого друга — `$`, если речь идёт о сеансе обычного пользователя, или символом решётки — `#`, для приглашения строки в сеансе администратора. Это — чистая условность: вид приглашения может быть настроен в широких пределах, причём по разному в разных оболочках. Об этом мы поговорим, когда речь дойдёт до описания конкретного шелла — `Zsh`.

Командная строка — визуальное представление среды, в которой задаются основные элементы командного интерфейса: командные директивы с их аргументами и опциями.

Командная директива (или просто команда) — основная единица, посредством которой пользователь взаимодействует с шеллом. Она образуется по определенным правилам, именуемым синтаксисом. Синтаксис командной директивы определяется, в первую очередь, языком, принятым в данной командной оболочке. Кроме того, некоторые команды (не очень многочисленные, но весьма употребимые) имеют собственный, нестандартный синтаксис.

Однако в целом базовые правила построения команд имеют много общего. И именно эти базовые правила станут предметом данного раздела. Синтаксические особенности отдельных нестандартных команд будут оговариваться по ходу изложения.

Итак, командная директива образуется:

* именем команды, однозначно определяющим ее назначение,
* опциями, определяющими условия выполнения команды, и
* аргументами — объектами, над которым осуществляются действия.

Очевидно, что имя команды является обязательным компонентом, тогда как опции и аргументы могут и отсутствовать (или подразумеваться в неявном виде по умолчанию).

ещё один непременный компонент командной директивы — это специальный невидимый символ конца строки: именно его ввод отправляет команду на исполнение. В обыденной жизни этот символ вводится нажатием и отпусканием клавиши `Enter`. Почему обычно и говорят: для исполнения команды нажмите клавишу `Enter`. Тот же эффект, как правило, достигается комбинацией клавиш `Control+M`. Символа конца командной строки, знаменующего исполнение команды, мы на экране не видим. Однако важно, что это — такой же символ, как и любой другой (хотя и имеющий специальное значение).

В подавляющем большинстве случаев опции (или их последовательности) задаются непосредственно за именем команды, а аргумент (или группа аргументов) команду завершает, хотя это правило имеет некоторые исключения. Вне зависимости от порядка опций и аргументов, принятых для данной команды, интерпретация их осуществляется слева направо.

Команды, опции и аргументы обязательно разделяются между собой пробелами. Кроме того, опции обычно предваряются (без пробела) символом дефиса или двойного дефиса. Впрочем, немногочисленные (но весьма употребимые) команды могут использоваться с опциями без всяких предваряющих символов.

Как уже говорилось, имя команды определяет выполняемые ею функции. Существуют команды, встроенные в оболочку, то есть не имеющие запускающих их исполняемых файлов, и команды внешние. В последнем случае имя команды однозначно указывает на имя исполняемого файла программы, выполняемой при отдаче соответствующей директивы. Часто встроенные и внешние команды одного назначения имеют одинаковые имена. В этом случае обычно предпочтительно использование встроенных команд — впрочем, они и вызываются в первую очередь. Для вызова одноимённой внешней команды её нужно задать с указанием пути. Так, директива

```console
$ time search for Mint in path2/
```

вызовет для определения времени выполнения команды `search` (о ней будет рассказываться в следующем очерке) встроенную команду `time`. А в форме

```console
$ /usr/bin/time search for Mint in path2/
```

будет задействована внешняя утилита с тем же именем. Кстати, это один из тех случаев, когда второй вариант может иногда оказаться предпочтительней: встроенная и внешняя команды имеют разные форматы вывода, причём в первой он зависит от используемой командной оболочки. И потому она не всегда подходит для прямого сравнения результатов — например, быстродействия в разных системах.

Определить, является ли данная команда встроенной в оболочку или внешней, можно с помощью встроенных команд `type` или `which`. Для встроенных команд вывод их будет таким:

```console
$ type which

which is a shell builtin

$ which type

type: shell built-in command
```

Или, в некоторых случаях, таким:

```console
$ which time

time: shell reserved word

$ type time

time is a reserved word
```

Для внешних команд любой из этих вариантов даст в выводе путь к исполняемому файлу:

```console
$ which date

/bin/date

$ type date

/bin/date
```

Некоторые команды могут выступать под несколькими именами. Это связано с тем, что исторически в различных Unix-системах команды, исполнявшие одинаковые функции, могли получать разные названия. В каждой конкретной системе обычно используется только одна из таких команд-дублеров. Но при этом имена дублирующих команд также могут присутствовать в системе — для совместимости. Не следует думать, что это две различные программы одного назначения: как правило, такая синонимичность команд реализуется посредством механизма ссылок (links) или псевдонимов (alias), о которых речь пойдёт позднее.

Иногда команда, вызванная через имя своего синонима, может отличаться по своей функциональности от самой же себя, вызванной под родным именем. В этом случае говорят о эмуляции одной команды другой. Типичный пример — командная оболочка `/bin/bash` в большинстве дистрибутивов Linux имеет своего дублера — `/bin/sh`; вызванная таким образом, она воспроизводит базовую функциональность стандарта POSIX-шелла.

### Автодополнение

Для правильного применения команд, конечно же, нужно знать их имена и назначение. Однако нас никто не заставляет напрягать пальцы вводом имени команды полностью. Потому что тут на помощь приходит великий метод автодополнения.

Благодаря этому методу для любой команды достаточно ввести первые несколько ее символов — и нажать клавишу табуляции (`Tab`). И, если введённых буковок достаточно для однозначной идентификации, полное имя команды волшебным образом возникнет в строке. Если же наш ввод допускает альтернативы продолжения имени — все они высветятся на экране (сразу или после повторного нажатия на табулятор), и из них можно будет выбрать подходящую.

Большинство употребимых команд POSIX-систем — коротки и мнемонически прозрачны. И может показаться. что не такое уж это облегчение — заменить ввод двух-трех символов нажатием табулятора (а то ещё и неоднократным). Однако, когда речь дойдет до аргументов команд — тут вся мощь автодополнения станет явной.

И ещё маленькое отступление. Автодополнение — стандартная возможность `Bash` и всех других командных оболочек, относимых к категории развитых. Но как раз в стандарте `POSIX` эта возможность не предусмотрена, и потому `POSIX shell` ее лишён. Нет этой функции и в `Dash` — системной командной оболочке `Mint`. Которая, впрочем, в интерактивном режиме не используется.

Ещё один способ облегчения ввода команд — обращение к их истории, о чём разговор будет несколько позже.

### Опции

Указания только имени команды достаточно для выполнения некоторых из них. Типичный пример — команда `ls` (от list), предназначенная для просмотра имен файлов (строго говоря, содержимого каталогов). Данная без аргументов, она выводит список имен файлов, составляющих текущий каталог, представленный в некоторой форме по умолчанию, например, в домашнем каталоге пользователя это будет выглядеть примерно так:

```console
$ ls

Desktop/    Downloads/   Music/  Pictures/  Templates/
Documents/  lost+found/  mytmp/  Public/    Videos/
```

Исполнение же многих других команд невозможно без указания опций и (или) аргументов. Для них в ответ на ввод одного её имени часто следует не сообщение об ошибке (или не только оно), но и краткая справка по использованию команды. Например, в ответ на ввод команды для создания каталогов `mkdir` (от make directory) последует следующий вывод:

```console
usage: mkdir [-pv] [-m mode] directory ...
```

Для одних опций достаточно факта присутствия в командой директиве, другие же требуют указания их значений (даваемых после опции обычно через знак равенства). В приведённом примере команды `mkdir` к первым относятся опции `-v` (или `--verbose`), предписывающая выводит информацию о ходе выполнения команды (запомним эту опцию — в том же смысле она используется чуть ли не во всех командах Unix), и `-p`, которая позволяет создать любую цепочку промежуточных каталогов между текущим и новообразуемым (в случае их отсутствия).

А вот опция `-m`, определяющая атрибуты доступа к создаваемому каталогу, обязательно требует указания значения — этих самых атрибутов, заданных в символьной форме.

Многие опции имеют две формы — краткую, односимвольную, и полную, или многосимвольную, Некоторые же опции могут быть даны только в многосимвольной форме. Общее правило здесь таково: если одного символа достаточно для однозначного определения опции, могут употребляться обе формы в качестве равноправных. Однако поскольку количество символов латинского алфавита ограниченно (а человеческая фантазия, конструирующая опции — безгранична), при большом количестве опций одной команды некоторые из них приходится делать исключительно многосимвольными.

Продемонстрирую это на примере опций все той же команды `mkdir`. Полный их список будет следующим:

```
-m, --mode=MODE установить код доступа
        (как в chmod)
-p, --parents не выдавать ошибок,
        если существует, создавать
        родительские каталоги,
        если необходимо
-v, --verbose печатать сообщение
        о каждом созданном каталоге
--help показать помощь и выйти
--version  вывести информацию
        о версии и выйти
```

Очевидно, что для опции `--version` краткая форма совпала бы с таковой для опции `--verbose`, и потому первая существует только в полной форме. А вот для опции `--help` краткая форма в большинстве команд возможна, и она выглядит как `-h`. Более того, во многих командах вызов помощи может быть вызван посредством опции `-?`. К слову сказать — приведенный выше список опций команды `mkdir` получен именно таким способом.

Раз уж зашла речь об опциях `--version` и `-h` (`--help`, `-?`), давайте и их запомним на будущее. Это — так называемые стандартные опции GNU, в число коих входит и опция `-v`, `--verbose`. Назначение «длинной» их формы (`--version`, `--help`, `--verbose`) идентично почти во всех командах, краткой — во многих.

Опять-таки, из того же примера видно, что опции в односимвольной форме предваряются единичным символом дефиса и могут быть даны единым блоком, без пробелов:

```console
$ mkdir -vpm 777 dir/subdir
```

При этом, естественно, опция, требующая указания значений, ставится последней, и ее значение отделяется пробелом. Опции же в многосимвольной форме требуют предварения удвоенным дефисом, обязательно должны разделяться пробелами и значения их, если таковые требуются, присваиваются через символ равенства (по научному он называется ещё оператором присваивания):

```console
$ mkdir --parents --mode=777 dir/subdir
```

Загадочные семерки после опции `-m` (`--mode`) — это и есть те самые атрибуты доступа, данные в символьной нотации, о которых речь пойдёт в соответствующем разделе.

Опции команды именуются также флагами (реже ключами) или параметрами. Однозначной трактовки этих терминов нет. Однако обычно под флагами подразумеваются опции, не требующие указания значений. Термин параметр же применяется к опции, такового требующей, и объединяет опцию и ее значение. Правда, мне встречалось определение параметра как совокупности опций и аргументов, но я буду придерживаться приведенных определений.

Порядок опций, если их приводится более одной, для большинства команд не существенен. Хотя, например, для команды `tar`, создающей файловые архивы, опция `-f`, значением которой является имя создаваемого или распаковываемого архива, традиционно указывается последней. И, к слову сказать, именно эта команда — одна из немногих, опции которой не обязаны предваряться символами дефиса. Так, директивы

```console
$ tar cf filename.tar dir
```

и

```console
$ tar -cf filename.tar dir
```

абсолютно равноценны: и та, и другая создает единый архивный файл `filename.tar` из отдельных файлов каталога `dir`.

Особый смысл имеет символ удвоенного дефиса `--`, если после него не следует никакой опции: таким образом обозначается конец списка опций, и все последующие, отделённые пробелом, символы интерпретируются как аргументы. Одинарный же дефис с последующим пробелом, напротив, подменяет аргументы команды, то есть в качестве таковых рассматривается стандартный ввод: знание этого нам потребуется, когда речь дойдёт до командных конвейеров.

### Пример: опции команды ls

Опции определяют условия выполнения команды. На предыдущей странице был приведён пример команды `ls` без опций. Однако на самом деле отсутствием опций при ней определяется вид выводимого списка по умолчанию — как многоколочночного списка, состоящего из имен файлов без учета т.н. скрытых файлов (а таковыми являются файлы, имена которых начинаются с символа точки, почему они ещё называются dot-файлами), без каких-либо их атрибутов и без визуального различия файлов различных типов.

Различные же опции команды `ls` определяют состав и формат выводимого списка файлов. Так, в форме

```console
$ ls -a
```

она обеспечивает вывод списка имен всех файлов текущего каталога, включая скрытые файлы вида `.*` (символ `*` здесь обозначает шаблон имени, соответствующий любому количеству любых символов — в том числе и нулевому, то есть отсутствию оных), символы текущего (`./`) каталога и каталога родительского (`../`).

В форме

```console
$ ls -l
```

дается вывод списка имен файлов в «длинном» формате (отсюда название опции `-l` — от long), то есть с указанием атрибутов доступа, принадлежности, времени модификации, размера и некоторых других характеристик:

```
drwxrwxr-x. 14 alv alv 4,0K Мар 14 08:40 current/
drwxr-xr-x.  2 alv alv 4,0K Фев  8 11:28 Desktop/
drwx------.  5 alv alv 4,0K Мар 11 18:34 priv/
```

Форма

```console
$ ls -F
```

позволяет получить список файлов с символьным различением файлов различных типов. Например, имя каталога будет выглядеть как `dirname/`, имя исполнимого файла — как `filename*` (здесь звездочка — не шаблон имени, а символическое обозначение исполняемого файла), и так далее.

Я столь подробно остановился на команде `ls` не только из-за многочисленности ее опций: это — одна из самых употребимых команд для просмотра файловой системы. И, должным образом настроенная (в том числе и с помощью приведенных опций), она дает ничуть не менее информативную и зрительно выразительную картину, чем развитые файловые менеджеры типа `Midnight Commander` или многочисленные файловых менеджеры графического режима.

### Аргументы

Таким образом мы подобрались к понятию аргументов командной директивы. Аргументами определяется, как правило, объект (или объекты) действия команды. В большинстве случаев в качестве аргументов команд выступают имена файлов и (или) пути к ним.

Выше говорилось, что при отсутствии аргументов команда `ls` выводит список имен файлов текущего каталога. Это значит, что текущий каталог выступает как заданный неявным образом (по умолчанию) аргумент команды `ls`. Если же требуется вывести список имен файлов каталога, отличного от текущего, путь к нему должен быть указан в качестве аргумента команды явно, например:

```console
$ ls /usr/bin
```

Большинство команд допускает указание не одного, а нескольких (и даже очень многих) аргументов. Так, единой директивой вида

```console
$ cp file1 file2 ... fileN dir
```

можно скопировать (команда `cp` — от copy) сколько угодно файлов из текущего каталога в каталог `dir` (на самом деле на это «сколько угодно» накладываются некоторые теоретические ограничения, определяемые максимально возможной длиной командной строки, но практически предел этот очень далек).

Маленькое отступление. Упоминание команды `cp` — удобный случай чуть вернуться назад и рассмотреть одну очень важную опцию, почти универсальную для команд POSIX-систем. Для начала попробуем скопировать один каталог в другой:

```console
$ cp dir1 dir2
```

Как вы думаете, что получится в результате? Правильно, сообщение о невозможности выполнения этой операции — примерно в таком виде:

```console
cp: omitting directory 'dir1'
```

поскольку команда `cp` в чистом виде для копирования каталогов не предназначена. Что делать? Очень просто — указать опцию `-R` (от Recursive; в большинстве систем проходит и опция `-r` с тем же смыслом, но первая форма работает абсолютно везде. В результате в каталог `dir2` не только будут скопированы сам каталог `dir1` и все входящие в него файлы, но и вложенные подкаталоги из `dir1`, если таковые имеются.

Маленькое уточнение: вполне возможно, что в дистрибутиве, который имеется в вашем распоряжении, проходит и копирование каталогов просто через `cp`, без всяких дополнительных опций. Это — потому, что команда `cp` часто определяется как псевдоним самой себя с опцией рекурсивного копирования, о чем скоро пойдет речь.

Вообще рекурсия (то есть определение некоего выражения через самого себя) — очень важное понятие в Unix, пронизывающее происходящие от нее системы насквозь. И послужившие даже базой для своеобразного хакерского юмора. Однако сейчас для нас важно только то, что рекурсия применима практически ко всем файловым операциям, позволяя распространить действие одной командной директивы не только на файлы данного каталога, но и на все вложенные подкаталоги и их содержимое.

Однако вернемся к аргументам. Действие некоторых команд неоднозначно в зависимости от аргументов, к которым она применяется. Например, команда `mv` служит как для переименования файлов, так и для их перемещёния в другой каталог. Как же она узнает, что ей делать в данном конкретном случае? Да именно по аргументам. Если дать ее в форме

```console
$ mv filename1 filename2
```

то следствием будет переименование `filename1` в `filename2`. А вот если первым аргументом указан файл, а вторым — каталог, например

```console
$ mv filename dir
```

то результатом будет перемещёние `filename` из текущего каталога в каталог `dir`. К слову сказать, команды типа `mv` воспринимают разное количество аргументов в зависимости от того, какие они, эти аргументы. В первом примере аргументов может быть только два — имя исходного файла и имя файла целевого. Зато во втором примере в качестве аргументов можно задать сколько угодно файлов и каталогов (с учетом вышеприведенной оговорки относительно «сколько угодно») — все они будут перемещёны в тот каталог, который окажется последним в списке. То есть директивой:

```console
$ mv file1 ... fileN dir1 ... dirM dirN
```

в каталог `dirN` будут перемещёны все файлы `file1 ... fileN` и все каталоги `dir1 ... dirM`. Характерно, что для этого команде `mv`, в отличие от команды `cp`, ей не требуется каких-либо дополнительных опций — она рекурсивна по самой своей природе.

### Пути к файлам

Для правильного построения аргументов команды требуется рассмотрение ещё одного понятия — пути к файлу. Путь — это точное позиционирование файла в файловой системе относительно ее корня (обозначаемого символом прямого слэша — `/`) или нашего в ней положения — текущего каталога (который, напомню, символически обозначается единичной точкой — `.`).

Так, если пользователь находится в своем домашнем каталоге (абсолютный путь к нему обычно выглядит как `/home/username`), то просмотреть содержимое каталога `/usr/bin` он может двумя способами — тем, который был дан в предыдущем примере, или вот так:

```console
$ ls ../../usr/bin
```

Первый путь в аргументе команды `ls` — абсолютный, отсчитываемый от корневого каталога, второй — задается относительно каталога текущего, ведь `../` — это родительский каталог для него.

Пути в аргументах команд могут быть весьма длинными. Например, чтобы просмотреть список шрифтов, применяемых в интерфейсе Cinnamon по умолчанию, нужно дать команду следующего вида:

```console
$ ls /usr/share/fonts/truetype/noto
```

И читатель вправе спросить — неужели мне все это вводить вручную? Отнюдь — отвечу я ему. Потому что автодополнение, о котором упоминалось по ходу разговора об именах команд, действует также для путей в их аргументах — последовательным нажатием клавиши табуляции все недостающие символы будут добавляться

Ещё один способ избежать набора длинных путей к файлам — это определение переменной `PATH`. Внимательный читатель, вероятно, обратил внимание, что при наборе команды путь к исполняемому её файлу не указывается. Для внутренних команд причина понятна — они прошиты в самой оболочке. А как мы обходимся без указания путей к командам внешним? Неужели система мистическим чувством определяет, где они находятся?

Отнюдь, ни малейшей мистики, Просто каталоги, в которых находятся команды (а это, как правило, `/bin`, `/sbin`, `/usr/bin`, `/usr/sbin`) определены в качестве значений переменной `PATH`, о чём мы подробнее поговорим со временем.

### Кое-что об исключениях

Итак, типичная форма POSIX-команды в обобщенном виде выглядит следующим образом:

```console
$ command -[options] [arguments]
```

Из этого правила выбиваются немногочисленные, но весьма полезные и часто используемые команды. Однако и для таких команд с нестандартным синтаксисом устанавливаются те же компоненты — имя, опции, аргументы, хотя по ряду причин (в том числе исторических) порядок их может меняться.

Это можно проиллюстрировать на примере полезнейшей команды `find`, предназначенной для поиска файлов (и не только для этого — она являет собой почти универсальное орудие в деле всякого рода файловых манипуляций). В типичной своей форме она выглядит примерно следующим образом:

```console
$ find dir -option1 value -option2 [value]
```

Здесь `dir` — каталог, в котором выполняется поиск, — может рассматриваться в качестве аргумента команды. Опция `-option1` (обратим внимание, что здесь, не смотря на многосимвольность опций, они предваряются единичным символом дефиса) и ее значение value определяют критерий поиска, например, `-name filename` — поиск файла с указанным именем, а опция `-option2` предписывает, что же делать с найденным файлом (файлами), например, `-print` — вывести его имя на экран. причём опция действия также может иметь значение. Например, значением опции `-exec` будет имя команды, вызываемой для обработки найденного файла (файлов). Так, директива вида

```console
$ find ~/ -name *.tar -exec tar xf {} ;
```

требует отыскать в домашнем каталоге (`~/`), выступающем в качестве аргумента, файлы, имя которых (первая опция — критерий поиска) соответствует шаблону `*.tar` (значение первой опции), и выполнить (вторая опция — действия) в их отношении команду `tar` с собственными опциями, обеспечивающими распаковку архивов (значение второй опции). Интересно, что в этом контексте в качестве значений второй опции команды `find` выступает не только внешняя команда, но и все относящиеся к ней опции.

В последнем примере имеется несколько символов, смысл которых может показаться непонятным. Надеюсь, он прояснится достаточно скоро — в разговоре о регулярных выражениях.

### Псевдонимы

Вернемся на минуту к команде `ls`. У читателя может возникнуть вполне резонный вопрос: а если я всегда хочу видеть ее вывод с символическим различением типов файлов, да ещё в «длинном» формате? Ну и без вывода скрытых файлов мне никак не прожить. И что же — мне каждый раз вводить кучу опций, чтобы получить столь элементарный эффект?

Отнюдь — ответил бы граф, стуча манжетами о подоконник. Потому что этот вопрос задавали себе многие поколения не только пользователей, но и разработчиков. И ответили на него просто — введением понятия псевдонима команды (alias).

Что это такое? В большинстве случаев — просто некоторое условное имя, подменяющее определённую команду с теми её опциями, которые мы используем чаще всего. Причём, что характерно, псевдоним команды может совпадать с ее именем. То есть, например, — набирая просто `ls`, мы получаем список файлов не в умолчальном формате, а в том, в каком угодно нам.

Устанавливаются псевдонимы очень просто — одноименной командой `alias`, в качестве аргументов которой выступают имя псевдонима и его значение, соединенные оператором присваивания (именуемым в просторечии знаком равенства). А именно, если мы хотим ныне, и присно, и во веки веков видеть вывод команды `ls` с символьным различением типов файлов, нам достаточно дать команду вроде следующей:

```console
$ alias ls='ls -F
```

Здесь следует обратить внимание на два момента: а) на то, что имя псевдонима совпадает с именем команды (что отнюдь не препятствует создания псевдонима типа `ll='ls -l'` специально для вывода файловых списков в длинном формате), и б) на одинарные кавычки, в которые заключено значение псевдонима. Смысл их станет ясен несколькими параграфами позже, а пока просто запомним, что кавычки (и именно одинарные) — обязательный атрибут команды установки псевдонима.

Таким образом мы можем наделать себе псевдонимов на все случаи жизни. В разумных пределах, конечно — иначе вместо упрощения жизни мы создадим себе необходимость запоминания множество невнятных сочетаний символов. Однако на наиболее важных (и обычно определяемых) псевдонимах я остановлюсь.

Вспомним команды типа `cp` и `mv`, которыми мы, в частности, можем скопировать или переместить какие-то файлы из каталога в каталог. А что произойдет, если чисто случайно в целевом каталоге уже имеются файлы, одноименные копируемым/перемещаемым? Произойдет штука, могущая иметь весьма неприятные последствия: файлы в целевом каталоге будут заменены новыми, теми, что копируются туда или перемещаются. То есть исходное содержание этих файлов будет утрачено — и безвозвратно, восстановить его будет невозможно никакими силами.

Разумеется, иногда так и нужно, например, при полном резервном копировании старые версии файлов и должны быть заменены их более свежими вариантами. Однако такое приемлемо далеко не всегда. И потому в большинстве команд, связанных с необратимыми изменениями файловой системы, предусматривается специальная опция — `-i` (или `--interactive`). Если задать эту опцию с командой `cp` или `mv`, то при совпадении имён исходного и целевого файлов будет запрошено подтверждение на выполнение соответствующего действия:

```console
$ cp file1 file2

cp: overwrite  file2'?
```

И пользователь может решить, нужно ли ему затирать существующий файл, ответив `yes` (обычно достаточно `y`), или это нежелательно, и должно ответить no (а также просто `n` — или не отвечать ничего, это равноценно в данном случае отрицательному ответу).

Так вот, дабы не держать в голове необходимость опции `-i` (ведь, как я уже говорил, пропуск ее в неподходящий момент может привести к весьма печальным результатам), в подавляющем большинстве систем для команд `cp` и `mv` (а также для команды `rm`, служащей для удаления файлов — эта операция также практически необратима) определяются одноименные им псевдонимы такого вида:

```console
$ alias cp='cp -i';

$ alias mv='mv -i';

$ alias rm='rm -i'
```

Все это, конечно, очень благородно, заметит внимательный читатель. Но что, если мне заведомо известно, что сотни, а то и тысячи файлов целевого каталога должны быть именно переписаны новыми своими версиями? Что же, сидеть и, как дурак, жать на клавишу `Y`?

Не обязательно. Потому что все команды рассматриваемого класса имеют ещё опцию `-f` (в «длинной» своей форме, `--force`, она также практически универсальна для большинства команд). Которая, отменяя действие опции `-i`, предписывает принудительно переписать все файлы целевого каталога их обновленными тезками. И никто не мешает нам на этот случай создать ещё один псевдоним для команды `cp`, например:

```console
$ alias cpf='cp -f'
```

Правда, предварительно нужно убедиться, что в системе нет уже команды с именем, совпадающим с именем псевдонима — иначе эффект может быть весьма неожиданным (впрочем, это относится ко всем псевдонимам, не совпадающим с именами подменяемых команд).

Есть и другой способ обойти опции, установленные для команды-псевдонима: просто отменить псевдоним. Что делается командой обратного значения

```console
$ unalias alias_name
```

То есть дав директиву

```console
$ unalias cp
```

мы вернем команде копирования ее первозданный смысл. Ну а узнать, какие псевдонимы у нас определены в данный момент, и каковы их значения, ещё проще: команда

```console
$ alias
```

без опций и аргументов выведет полный их список:

```
la='ls -A'
less='less -M'
li='ls -ial'
ll='ls -l'
ls='ls -F --color=auto'
```

и так далее.

Когда я сказан о пользовании псевдонимами ныне, и присно, и вовек, — то был не совсем точен. Ныне, то есть в текущем сеансе пользователя — да, они работают. Однако после рестарта системы (или просто после выхода из данного экземпляра командной оболочки) они исчезнут без следа. Чтобы заданные псевдонимы увековечить, их нужно прописать в конфигурационном файле пользовательского шелла. Но этим мы займемся впоследствии. А пока обратимся к переменным.

### Переменные

Переменные играют для аргументов команд примерно такую же роль, что и псевдонимы — для команд. То есть избавляют от необходимости мрачного ввода повторяющихся последовательностей символов. Конечно, это — далеко не единственное (а может быть, и не главное) назначение переменных, однако на данном этапе для нас наиболее существенное.

Что такое переменная? Ответ просто — некоторое имя, которому присвоено некоторое значение. Не очень понятно? — Согласен. Но, возможно, станет яснее в дальнейшем.

Имена переменных в принципе могут быть любыми, хотя некоторые ограничения также существуют. Я уже вскользь упоминал о переменных в разговоре про пути к файлам, где фигурировала переменная `PATH`. Когда дело дойлёт у нас до пользовательских аккаунтов, придётся поговорить о переменных `SHELL`, `USER`, `HOME`.

Все эти (и ещё некоторые) имена зарезервированы за внутренними, или встроенными, переменными оболочки (некий минимальный их набор имеется в любом шелле). То есть значения их определены раз и навсегда. и пользователем не изменяются. То есть он, конечно, может их изменить, если очень хочет — но ничего доброго, кроме путаницы, из этого не выйдет.

Таких встроенных переменных довольно много. Одна из первых по значению — всё та же переменная `PATH`. Это — список каталогов, в которых оболочка, в ответ на ввод пользователя в командной строке, ищет исполнимые файлы — то есть просто команды. Я уже обращал внимание, что во всех приведённых выше примерах имена команд указывались без всяких путей к ним (в отличие от файлов-аргументов, путь к которым — обязателен). Так вот, успех её поисков и определяется списком значений переменной `PATH`. Каковые могут быть просмотрены командой `echo`:

```console
$ echo $PATH
```

Обратим внимание на то, что в качества аргумента команды выступает не просто имя переменной, а оно же, но предваренное символом доллара. Который в данном случае никакого отношения к приглашению командной строки не имеет, а предписывает команде `echo` подменить имя переменной ее значением (значениями). В большинстве дистрибутивов Linux случае вывод команды для пользователя будет в обязательном порядке включать такие каталоги:

```
/bin:/usr/bin:/usr/local/bin
```

Для администратора системы сюда обязательно добавятся каталоги `/sbin`, `/usr/sbin` и `/usr/local/sbin`. Остальные значения переменной `PATH` могут варьировать по умолчанию, а также задаваться пользователем (как — поговорим позже).

Обратим вниммание на одно важное обстоятельство: практически во всех дистрибутивах Linux и в более иных ОС в перечне значений переменной `PATH` отсуствует текущий каталог

Тем временем вернемся к переменной `HOME`. Значение ее — полный абсолютный путь к домашнему каталогу пользователя. То есть, чтобы перейти в него, пользователю по имени `alv` вместо

```console
$ cd /home/alv
```

достаточно набрать

```console
$ cd $HOME
```

и он в своих владениях. Может показаться, что экономия — грошовая (тем паче, что перейти в собственный каталог пользователь может просто командой `cd` без всяких аргументов), но минуту терпения — и выгоду от использования переменных вы увидите.

Кроме переменных, предопределенных в шелле, пользователю предоставляется почти полная свобода в определении переменных собственных. И вот тут-то и наступает ему обещанное облегчение при наборе аргументов команд.

Предположим, что у нас имеется глубоко вложенный подкаталог с данными, постоянно требующимися в работе. Чисто условно примем, что путь к нему — следующий:

```
/home/alv/data/all.my.works/geology/plate-tectonics
```

Весьма удручающе для набора, даже если исправно работать табулятором для автодополнения, не так ли? Прекрасно, упрощаем себе жизнь определением переменной:

```console
$ plate=/home/alv/data/all.my.works/geology/plate-tectonics
```

Дело в шляпе, Теперь, если нам нужно просмотреть состав этого каталога, достаточно будет команды

```console
$ ls $plate
```

А вызвать из него любой файл для редактирования можно так:

```console
$ joe $plate/filename
```

Подобно псевдонимам, переменные, определенные таким образом (то есть просто в командной строке), имеют силу только в текущем сеансе работы — по выходе из оболочки они утрачиваются. Для того, чтобы они действовали перманентно, переменные должны быть прописаны в конфигурационном файле пользовательского шелла. Однако, в отличие от псевдонимов, и этого оказывается не всегда достаточно. Ибо переменная, определенная посредством

```console
$ NAME=Value
```

работает не просто только в текущем сеансе — но ещё и только в конкретном экземпляре шелла. Почему и называется переменной оболочки — shell variable. Звучит это. быть может, пока не очень понятно. Однако практически любое действие в шелле — запуск команды или программы, например, — начинается с того, что оболочка, в которой это действие совершается, запускает новый экземпляр самой себя — дочерний шелл, или, как иногда говорят, субшелл.

Так вот, этот самый субшелл не наследует переменные родительской оболочки. И в итоге запущенная из командной строки программа ничего не будет знать, например, о путях к исполняемым файлам. Что автоматически ведет к невозможности запуска из нее команд просто по имени, без указания точного пути.

Чтобы избежать такой неприятной ситуации, было придумано понятие переменных окружения, или переменных среды — environment variable. Это — те переменные, которые наследуются от родительского шелла всеми дочерними программами. И чтобы сделать их таковыми, переменные следует экспортировать. Как? Командой export, которая может быть применена двояким образом. Можно сначала определить переменную:

```console
$ NAME=Value
```

а затем применить к ней команду `export`:

```console
$ export NAME
```

А можно сделать это в один прием:

```console
$ export NAME=Value
```

Второй способ применяется, если нужно определить и экспортировать одну переменную. Если же за раз определяется несколько переменных:

```console
$ NAME1=Value1;

$ NAME2=Value2;

...;

$ NAMEN=ValueN
```

то проще прибегнуть к первому способу, так как команда `export` может иметь сколько угодно аргументов:

```console
$ export NAME1 NAME2 ... NAMEN
```

Традиционно имена переменных окружения задаются в верхнем регистре, переменных оболочки — в нижнем.

### Навигация и редактирование

Имя команды, ее опции и аргументы образуют т.н. командные «слова». В качестве словоразделителей выступают пробелы. Кроме того, как разделители «слов» интерпретируется ряд специальных символов — прямой слэш (`/`) — элемент пути к файлу, обратный слэш (`\`), служащий для экранирования специальных символов, и операторы командных конструкций, о которых будет сказано ниже.

В некоторых случаях имеет смысл различать «большое слово» и «малое слово». Первые разделяются пробелами, в качестве же вторых интерпретируются символы, лежащие между всеми другими словоразделителями.

Подчеркнем, что командное «слово» прямо не соотносится ни с опциями, ни с аргументами команды. Введение этого понятия призвано просто облегчить навигацию в командной строке и ее редактирование.

Ибо одно из великих достижений командного интерфейса POSIX-систем, заценить которое могут в полной мере только те, кто застал времена «черного DOS'а», — это возможность перемещёния внутри командной строки и внесения необходимых изменений в имя команды, ее опции и аргументы. Делается это различными способами.

Самый привычный и, казалось бы, очевидный способ — использование клавиш перемещёния курсора `Left`, `Right`, `End` и `Home`, действующих (хотя и не всегда) в командной строке точно так же, как и в каком-нибудь ворд-процессоре для Windows (клавиши `Up`, `Down`, `PageUp`, `PageDown` зарезервированы для других целей). То есть они позволяют перемещаться на один символ влево и вправо. в начало и конец командной строки. А если добавить сюда ещё клавиши `Delete` и `Backspace`, позволяющие удалять символы в позиции курсора или перед ней — то, казалось бы, чего ещё желать?

Оказывается — есть чего, и самый очевидный способ навигации и редактирования оказывается не самым эффективным. Для начала заметим, что в общем случае привычные клавиши перемещёния курсора и редактирования в POSIX-системах не обязаны работать также, как они делают это в DOS/Windows. Это зависит от многих причин, в том числе и исторических. Ведь POSIX-системы по определению предназначены работать на любых практически машинах (в том числе и на тех, клавиатуры которых клавиш управления курсором просто не имели).

Однако это не главное — в большинстве Linux-дистрибутивов командная оболочка по умолчанию настраивается так, чтобы пользователь при желании мог использовать привычные ему клавиши. Однако тут-то и оказывается, что плюс к этому оболочка предоставляет ему много более эффективную систему навигации по командной строке и ее редактирования. И это — система управляющих последовательностей, так называемых keybindings. То есть сочетания специальных клавиш, именуемых управляющими, с обычными алфавитно-цифровыми.

### Управляющие последовательности

Основные управляющиеся клавиши, которые используются в таких последовательностях (и имеются на клавиатурах почти любых машин — как говорят в таких случаях, в любых типах терминалов) — это клавиши `Control` и `Meta`.

Пардон — возразит внимательный читатель, — сколько я ни долблю по клавишам моей PC'шки, но клавиши `Meta` не замечал. Возражение принято, но: на PC-клавиатурах функции Meta выполняют либо а) нажатие и отпускание клавиши `Escape`, либо б) нажатие и удерживание клавиши `Alt`.

Впрочем, к этой теме я ещё вернусь. А пока достаточно нескольких простых рецептов, практически универсальных для любых командных оболочек в терминалах любых типов.

Рецепт первый: большая часть управляющих последовательностей состоит из сочетания клавиши `Control` и алфавитно-цифрового символа. Под сочетанием (или комбинацией, для чего я уже употреблял ранее символ плюс) понимается то, что, удерживая нажатой клавишу `Control`, мы одновременно нажимаем и какую-нибудь литерную или цифровую.

Так, действие клавишной комбинации `Control+F` (от `Forward` — в большинстве случаев регистр алфавитной клавиши управляющей последовательности значения не имеет) эквивалентно нажатию клавиши `Right` — это перемещёние на один символ вправо, комбинации `Control+B` (от `Back`) — нажатию `Left` (перемещёние на один символ влево). Комбинации `Control+A` и `Control+E` действуют аналогично `Home` и `End`, перемещая курсор в начало и конец командной строки, соответственно, Ну а с помощью комбинаций `Control+D` и `Control+H` можно удалить единичный символ в позиции курсора или перед ней (также, как и клавишами `Delete` и `Backspace`, соответственно).

Предвижу резонный вопрос: а какие достоинства в комбинации клавиш `Control+Что_то` по сравнению с элементарными `End` или `Left`? Конечно, одно достоинство — очевидно: при массовом вводе команд (а также, забегая вперед, замечу — и любых иных наборов символов, от исходных текстов до романов), при использовании keybindings руки не отрываются от основной (алфавитно-цифровой) части клавиатуры. И в итоге, по приобретении некоторого минимального навыка, дело движется ну гораздо быстрее. Обосновать тестами не могу (тут какая-нибудь физиометрия понадобится), но не верящим — предлагаю попробовать.

Главное же преимущество клавиатурных последовательностей перед стандартными навигационными клавишами — много более широкая их функциональность. Я не случайно начал этот параграф с упоминания командных «слов» — это, наряду с единичными символами, также навигационные (и, добавлю, редакционные) единицы командной строки. То есть управляющие последовательности позволяют при навигации и редактировании оперировать не только единичными символами, но и целыми словами.

Например, комбинация `Meta+F` смещает курсор на одно «слово» вперед, та же `Meta` в сочетании с `B` — на одно слово назад, и так далее. Прошу обратить внимание: действие алфавитной клавиши в комбинации с `Meta` сходно по смыслу ее сочетанию с клавишей `Control`, но как бы «усилено»: последовательность `Meta+D` уничтожает не символ в позиции курсора, как это было бы для `D` в сочетании с `Control`, а все командное «слово».

Рассматривать ключевые последовательности подробно здесь я не буду: детали их действия зависят от командной оболочки и ее настроек. Отмечу только два существенных обстоятельства. Первое: keybindings предоставляют пользователю полный комплекс приемов для любых действий в командной строке — вплоть до преобразования регистров уже введенных символов и «слов» (из нижнего в верхний и наоборот), «перетасовки» символов в команде или ее аргументах, и так далее.

Значение управляющих последовательностей не ограничивается командной строкой — большинство популярных в POSIX-мире текстовых редакторов, от простых `Nano` или `joe` до грандиозного `vim` и монструозного `emacs`. построены по тому же принципу. Так что навыки, полученные при работе с keybindings, например, в Bash, весьма поспособствуют виртуозному освоению любого из этих инструментов.

И второе — действие ключевых последовательностей, как правило. не зависит не только от типа терминала и физического устройства клавиатуры, но и от ее раскладки — при переключении на кириллицу они будут работать столь же справно, как и в латинице.

### История команд

Возможности навигации и редактирования строки особенно ярко проявляются в сочетании с другой замечательной особенностью, предоставляемой командными оболочками — доступом к истории команд. То есть: раз введенная в строке команда не уходит в небытие после исполнения, а помещается в специальный буфер памяти. Который, как и все в Unix'ах, именуется весьма незатейливо — буфер истории команд. Откуда команда (со всеми её опциями и аргументами) может быть извлечена для повторного использования. Или — для редактирования и исполнения в новой реинкарнации.

Буфер истории команд сохраняется в течении всего сеанса работы. Однако в большинстве случаев командные оболочки настраиваются так, что по выходе из сеанса буфер истории сохраняется в специальном файле в домашнем каталоге пользователя, и таким образом его содержимое оказывается доступным при следующем запуске шелла. Имя этого файла может быть различным в разных оболочках, но обычно включает компонент `history` (в Bash — `~/.bash_history`).Так что, можно сказать, что введенным нами командам суждена вечная жизнь.

Конечно, не совсем вечная. И размер буфера истории команд, и количество строк в файле истории — величины конечные. Так что, если установленный предел превышен, то старые команды вытесняются более новыми. Однако и величину буфера, и количество строк в файле истории можно установить любыми. Разумеется, в разумных пределах — не знаю, существует ли принципиальное ограничение на их размер, за исключением объёма памяти и дискового пространства. А если учесть, что и из буфера, и из памяти с помощью соответствующих настроек (со временем я расскажу, каких) можно исключить дубликаты и ещё кое-какой мусор — то мое заявление о вечной жизни команд не выглядит столь уж преувеличенным.

Универсальное средство доступа к буферу истории команд — специальная команда, встроенная во все шеллы, таковой поддерживающие — `history` (в большинстве дистрибутивов Linux она по умолчанию имеет псевдоним — `h`). Данная без опций, эта команда выводит полный список команд в их исторической (издревле к современности) последовательности, или некоторое количество команд, определенных соответствующими настройками (о которых будет говориться позднее).

В качестве опции можно указать желаемое количество одновременно выведенных команд. Например, директива

```console
$ history -2
```

выведет две последние команды из буфера истории вместе с их номерами:

```console
1023  joe shell.html

1024  less ~/.zshrc
```

Любая из команд в буфере истории может быть повторно запущена на исполнение. Для этого достаточно набрать в командной строке символ `!` (восклицательный знак) и затем, без пробела — номер команды в списке буфера. Например,

```console
$ !1023
```

для приведенного выше примера повторно откроет файл `shell.html` в текстовом редакторе `joe`.

Другой способ доступа к командам из буфера истории — комбинации клавиш `Control+P` и `Control+N`, служащие для последовательного его просмотра (как бы «пролистывания») назад и, соответственно, вперед (разумеется, если есть куда). Они дублируются клавишами управления курсором `Up` и `Down` (назад и вперед, соответственно). Кроме того, последовательности `Meta+<` и `Meta+&rt;` обеспечивают переход к первой и последней команде в буфере истории.

Любая извлеченная (с помощью стрелок или управляющими последовательностями) из буфера истории в текущую строку команда может быть повторно запущена на исполнение — нажатием клавиши `Enter` или дублирующей ее комбинацией `Control+M`. причём предварительно ее можно отредактировать — изменить опции, или аргументы, — точно так же, как и только что введенную.

### Поиск в истории

Во всех современных «развитых» шеллах предусмотрены средства поиска команды в буфере истории — простым перебором (обычно `Meta+P` — назад и `Meta+N` — вперед).

Впрочем, не смотря на громкое название, обычный поиск ничем практически не отличается от пролистывания исторического списка курсорными стрелками. Что при обширной истории команд может быть весьма утомительным. И потому для ее облегчения предусмотрена такая интересная возможность, как наращиваемый поиск (incremental search) нужной команды в буфере истории по одному (или нескольким) из составляющих ее символов.

Выполняется инкрементный поиск так: после нажатия (при пустой командной строке) клавишной комбинации `Control+R` появляется предложение ввести алфавитный символ (или — последовательность символов произвольной длины), заведомо входящий в состав требуемой команды:

```console
$ bck-i-search: _
```

Ввод такого символа выведет последнюю из команд, его содержащих. При этом введенный символ будет отмечен знаком курсора. Он не обязан входить в имя команды, но может быть составляющим ее опций или аргументов (имени файла или пути к нему, например). Следующее нажатие `Control+R` зафиксирует курсор на предыдущем символе, в пределах этой же или более ранней по списку команды, и т.д. Однако вместо этого в строке поиска можно вводить дополнительные символы, детализирующие условия поиска команды (или — ее опций и аргументов).

Процедуру поиска можно продолжать вплоть до достижения требуемого результата — то есть нахождения той команды, которая нужна именно сейчас. Нажатие клавиши `Enter` в любой из этих моментов запускает найденную (то есть помещённую в командную строку) команду на исполнение, с завершением поиска. Поиск обрывается также и нажатием комбинации `Control+C`. Перед запуском найденная команда может быть отредактирована стандартными средствами — с использованием управляющих последовательностей.

### Регулярные выражения

Как известно, все пользователи-POSIX'ивисты должны быть в обязательном порядке привержены одному из семи смертных грехов. И грех этот — леность, можно сказать, показатель профессиональной пригодности линуксоида. В соответствие со своей леностью разработчики POSIX-систем придумывают способы, как бы им минимизировать свои усилия. А применители из лени изощряются в использовании этих приемов на практике. В частности — в том, как свести к минимуму набор в командной строке.

Собственно говоря, этой цели служили почти все приемы, описанные выше. Осталось осветить немногое. А именно — регулярные выражения, реализуемые с помощью т.н. специальных символов (или метасимволов).

Элементарная, и весьма частая, в духе школьных, задача: из каталога `dir1` требуется скопировать все файлы в каталог `dir2`. Так неужели все они должны быть перечислены в качестве аргументов команды `cp`? Нет, нет, и ещё раз нет. Ибо для этой цели придуманы шаблоны имен файлов. Самый часто используемый из них — специальный символ `*` (вроде бы я о нем уже говорил?). Он подменяет собой любое количество любых символов (в том числе — и нулевое, то есть отсутствие символов вообще). То есть для решения предложенной задачи нам достаточно дать команду:

```console
$ cp dir1/* dir2
```

Чуть усложним условия: к копированию из `dir1` предназначены не все файлы, а только html-документы, традиционно имеющие суффикс `html`. Решение от этого не становится сложнее:

```console
$ cp dir1/*html dir2
```

Однако тут можно вспомнить, что html-документы могут иметь и расширение `htm`. Не пропустим ли мы их таким образом при копировании? Таким — безусловно, пропустим. Однако нам на помощь придет другой шаблон — символ `?`. А соответствует он любому единичному символу (или — его отсутствию, т.е. символу null). И значит, если команда из примера будет модифицирована таким образом:

```console
$ cp dir1/*htm? dir2
```

то она гарантированно охватит все возможные маски html-документов.

Вроде все хорошо. Однако нет: из каталога `dir1` нам нужно скопировать только три определенных файла — `file1`, `file2`, `file3`. Не придется ли каждый из них указывать в командной строке с полным путем (а ведь они могут быть и в глубоко вложенном подкаталоге типа `dir1/dir11/dir111`)? Все равно не придется, на столь хитрую... постановку задачи у нас есть прием с левой резьбой — символы группировки аргументов, обозначаемые фигурными скобками. Что на практике выглядит так:

```console
$ cp path/{file1,file2,file3} dir2
```

И приведет к единоразовому копированию всех трех файлов в каталог `dir2`. Заметим, что сгруппированные аргументы разделяются запятыми без пробелов. И ещё: в оболочке Bash группируемые аргументы придется полностью вводить руками. Но вот в Zsh на них распространяется возможность автодополнения, да и запятая после каждого имени появляется автоматически (и столь же автоматически исчезает при закрытии фигурной скобки).

Группировка аргументов может быть сколь угодно глубоко вложенной. Так, команда

```console
$ mkdir -p dir1/{dir11/{dir111,dir112},dir12/{dir121,dir122}}
```

в один заход создаст трехуровневую структуру каталогов внутри текущего — если только не забыть про опцию `-p`, которая предписывает создавать промежуточные подкаталоги в случае их отсутствия.

И ещё несколько примеров. Регулярное выражение для диапазона — то есть вида `[...]`, подменяет любой из символов, заключенных в квадратные скобки. Символы эти могут даваться списком без пробелов (например, выражение `[12345]` соответствует любому символу от `1` до `5`) или определяться в диапазоне, крайние значения которого разделяются дефисом без пробелов (эквивалентное первому выражение — `[1-5]`). Кроме того, символ `^`, предваряющий список или диапазон, означает отрицание: выражение `[^abc]` подменяет любой символ, исключая символы `a`, `b` и `c`.

Последние примеры регулярных выражений могут показаться надуманными. Однако представим. что в том же каталоге `dir1`, кроме html-документов, содержатся также файлы изображений в различных форматах — GIF, JPEG, TIFF и так далее (традиционно имеющие одноименные расширения). И все они должны быть скопированы в каталог `dir2`, а вот как раз html-файлы нам в данный момент без надобности. No problemas, как говорят у них:

```console
$ cp dir1/*[^html] dir2
```

И в каталоге `dir2` окажется все содержимое каталога `dir1`, за исключением html-файлов.

### Экранирование

Из приведённых примеров можно видеть, что метасимволы, образующие регулярные выражения, интерпретируются командной оболочкой особым образом, не так, как обычные алфавитно-цифровые символы, составляющие, скажем, имена файлов.

В то же время собственно POSIX-системы накладывают на имена файлов очень мало ограничений. И в принципе система не запретит вам создать файл с именем, содержащим метасимволы. Другое дело, что работать с таким образом именованными файлами может быть сложно — командная оболочка будет пытаться интерпретировать их в соответствии с правилами для регулярных выражений.

Конечно, использовать метасимволы в именах файлов весьма не рекомендуется. Однако а) возможны элементарные ошибки при наборе, и б) файлы, полученные при обмене с другими операционными системами (сами знаете. какими), могут иметь довольно непривычный (и, я даже сказал бы, неприличный) вид.

Вспомним, что `MS Word` в качестве имени файла спокойно берёт первую фразу документа. А если это — вопрос? И тогда завершающий имя символ `?` будет в шелле интерпретироваться как шаблон, а не как элемент имени. Думаю, не нужно обладать очень развитым воображением, чтобы представить последствия. Что делать в таких ситуациях? Для их разрешения резонными людьми придумано было понятие экранирования.

Начнём с первого примера использования экранирования — разрыва длинных строк. Командные директивы, с многочисленными их опциями, особенно в полной форме, и аргументами могут оказаться весьма длинными, не укладывающимися в пределы экранной строки. Правда, обычно командная оболочка по умолчанию настраивается с разрешением так называемого word wrapping'а (то есть переноса «слов» команды без обрыва строки — последнее, как мы помним, достигается нажатием клавиши `Enter` или комбинации `Control+M` и приводит к немедленному исполнению введённой команды. Если ввод ее не окончен — последует сообщение об ошибке). Однако перенос «слов» при этом происходит, как бог на душу положит. И в результате командная директива теряет читабельность и становится сложной для понимания.

Тут-то и приходит на помощь понятие экранирования, упомянутое абзацем выше. Знак экранирования — обратный слэш (`\`), — превращает символ, имеющий специальное значение, например, упоминавшийся ранее шаблон в именах файлов — `*`, в самую обычную звездочку. А раз конец строки — тоже символ, хотя и специальный, то и он доступен для экранирования. Так что если завершить введённый фрагмент команды обратным слэшем (некоторые оболочки требуют предварить его пробелом, и лучше так и делать, хотя в Bash или Zsh пробел не обязателен), после чего нажать `Enter`, то вместо попытки исполнения будет образована новая строка. в которой можно продолжать ввод. Вид приглашения к вводу при этом изменится — это будет так называемое вторичное приглашение командной строки, и его представление настраиваемо, также как и вид приглашения первичного.

Возвращаемся к экранированию обратным слэшем. Действие его распространяется только на непосредственно следующий за ним символ. Если символы, могущие быть воспринятые как специальные, идут подряд, каждый из них должен предваряться обратным слэшем.

У обратного слэша есть ещё одна интересная особенность — я назвал бы ее инвертированием специального значения символов. Для примера: некая последовательность цифр (например, `033`), введенная в командной строке, будет воспринята как набор обычных символов. Однако она же может выступать как код какого-либо символа (в частности, `033` — код символа `Escape` в восьмеричной системе счисления). И подчас возникает необходимость ввода таких кодов (тот же код для `Escape`, скажем, затруднительно ввести каким-либо иным образом).

И вот тут обратный слэш проявляет свое инвертирующее действие: последовательность `\033` будет восприниматься уже не как набор символов, а как код символа `Escape` (обратим внимание, что тут достаточно единичного слэша). Непосредственно в командной строке такой способ инвертированного экранирования, по понятным причинам, обычно не используется, но находит широкое применение в сценариях.

### О кавычках

Есть и экраны, распространяемые на все, что заключено внутри них. Это — кавычки, двойные и одинарные: большая часть символов между ними утрачивает свое специальное значение. Но не все: в двойных кавычках сохраняют специальное значение метасимволы `$` и `\,` а также обратные кавычки (\`), о назначении которых я скажу чуть позже. То есть в них сохраняется возможность, с одной стороны, получения значений переменных (как мы помним, с помощью `$ИМЯ`). А с другой стороны, если нам требуется дать символ бакса в его прямом и привычном значении, у нас есть возможность заэкранировать его обратным слэшем. И если потребуется вывести на экран сообщение «с вас, уважаемый, пятьсот баксов», то это можно сделать таким образом:

```console
$ echo "с вас, уважаемый, \$500"
```

ещё одно широко применяемое использование двойных кавычек — экранирование пробелов, предотвращающих разбиение аргументов команды на отдельные «слова». Правда, в случае с командой echo это, как правило, не требуется (хотя настоятельно рекомендуется экранировать ее аргумент таким образом). Однако представьте, что в качестве аргумента команды копирования и перемещёния выступает файл, переписанный с Windows-машины. Ведь там пробелы в именах — вещь обычная. Тут-то экранирование двойными кавычками и придется к месту.

Из сказанного понятно, почему двойные кавычки именуются ещё неполными, или не строгими — они все же допускают внутри себя использование символов со специальными значениями. В противоположность им, кавычки одинарные носят имя строгих, или полных. Потому что между ними утрачивают специальное значение все метасимволы, кроме их самих — в том числе и символ единичного экранирования. В итоге они используются там, где гарантированно требуется отсутствие специальных символов. Если вы помните, мы применили строгие кавычки при установке псевдонимов. Они же часто оказываются обязательными при определении переменных.

Завершая тему экранирования, осталось сказать только об обратных кавычках. Их функция очень узка: они служат для экранирования команд. То есть, скажем, команда

```console
$ echo date
```

в полном соответствие со своим именем, просто выведет нам собственный аргумент:

```console
date
```

Однако если аргумент команды закрыть обратными кавычками, то date будет воспринято как имя команды, подлежащей исполнению. И результат этого исполнения (то есть текущая дата и время — а именно для их получения и предназначена команда date) будет замещать имя команды в выводе echo:

```console
$ echo `date`

Втр Дек 16 11:45:12 MSK 2003
```

Если вспомнить, что обратные кавычки сохраняют свое специальное значение внутри кавычек двойных, становится ясной польза от их применения: они незаменимы в тех случаях, когда требуется вывод результатов работы одной команды внутри другой. К как в нашем примере с выводом даты, если его (вывод) следует включить в некое выдаваемое командой echo сообщение.

Конечно, в описанном случае добиться той же цели можно было бы гораздо легче — просто командой date. Однако представьте, что у нас возникло желание одновременно и получить сведения о количестве пользователей в системе (для чего предназначена команда who). Тут-то и выясняется. что проще всего это сделать командой типа следующей:

```console
$ echo "На момент `date` в системе

        зарегистрированы `who`"
```

Ответом на что будет сообщение, подобное тому, что часто можно наблюдать на главной странице многих сайтов:

```console
На момент Сб. дек. 20 06:05:56 MSK 2014 в системе

зарегистрированы alv      tty8         2014-12-15 00:34 (:0)

alv      pts/1        2014-12-15 00:34 (:0)

alv      pts/5        2014-12-19 09:37 (:0)
```

А теперь последнее, чем и закроем тему регулярных выражений вообще. В этом разделе рассматривалось использование метасимволов в командной оболочке (конкретно, в данном случае. в Dash, Bash и Zsh). В других оболочках применение метасимволов и условия их экранирования могут несколько отличаться. И к тому же многие запускаемые из строки шелла команды могут иметь свои правила построения регулярных выражений. Так что в итоге их форма определяется сочетанием особенностей конкретной оболочки и команды, из неё запущенной. Все это при необходимости будет оговариваться в дальнейшем.

А пока переходим к рассмотрению командных конструкций — одной из тех особенностей CLI, которая определяет мощь и универсальность этого интерфейса.

### Вводные слова о командных конструкциях

Надеюсь, из того, что было рассказано на предшествующих страницах, посвящённых CLI, читателю стало ясно, что подавляющее большинство команд в POSIX-системах очень просты по сути и предназначены для выполнения какого-либо одного элементарного действия.

То есть команда `cp` умеет только копировать файлы, команда `rm` — только удалять их, но зато делают они это хорошо. Подчас — через чур хорошо, что мог ощутить на себе каждый, кому «посчастливилось» по ошибке выдать директиву вроде

```console
$ rm -Rf *
```

Для тех, кто не испытал этого волнительного ощущения, поясню: результатом будет полное и безвозвратное уничтожение всех файлов от текущего каталога вниз (включая подкаталоги любой степени вложенности).

А если задать ту же команду от лица администратора, то, в зависимости от текущего положения на файловом древе, можно нечувствительно удалить что угодно, вплоть до системы целиком: одна из причине, почему повседневные действия не следует выполнять под root'ом.

Собственно, разделение любой задачи на серию элементарных операций — это и есть основной принцип работы в POSIX-системах, тот самый пресловутый Unix-way, о котором столько говорят его приверженцы.

Однако вслед за этапом решительного размежевания (эх, неистребимы в памяти нашего поколения слова товарища Ленина) должен наступить этап объединения, как за анализом явления следует синтез эмпирических данных о нём. И целям такого объединения служат командные конструкции.

Командные конструкции — очень важный компонент интерфейса командной строки. Они позволяют объединять несколько команд воедино и выполнять различные команды последовательно или параллельно. Для этого служат специальные символы — операторы: фонового режима, объединения, перенаправления и конвейеризации.

### Совместное выполнение команд

Простейшая командная конструкция — это выполнение команды в фоновом режиме, что вызывается вводом символа амперсанда после списка опций и (или аргументов):

```console
$ command [options] [arguments] &
```

В Bash и Zsh пробел перед символом амперсанда не обязателен, но в некоторых шеллах он требуется, и потому лучше возвести его ввод (как и во всех аналогичных случаях) в ранг привычки. После этого возвращается приглашение командной строки и возможен ввод любых других команд (в том числе и фоновых). Команды для параллельного исполнения можно задать и в той же строке:

```console
$ command1 & command2 & ... & commandN
```

В результате все команды, перечисленные в строке, кроме той, что указана последней, будут выполняться в фоновом режиме.

Существуют и конструкции для последовательного выполнения команд. Так, если ряд команд разделен в строке символом точки с запятой (`;`)

```console
$ command1 ; command2 ; ... ; commandN
```

то сначала будет выполнена команда `command1`, затем — `command1` и так далее. Молчаливо предполагается, что каждая из этих команд может иметь любое количество опций и аргументов. И, опять-таки, обрамление `;` пробелами не обязательно во многих командных оболочках. Сами по себе команды не обязаны быть связанными между собой каким-либо образом — в сущности, это просто эквивалент последовательного их ввода в командной строке:

```console
$ command1
$ command2
...
```

и так далее. При этом первая команда может, например, копировать файлы, вторая — осуществлять поиск, третья — выполнять сортировку, или другие действия. Очевидно, что в общем случае выполнение последующей команды не зависит от результатов работы предшествующей.

Однако возможна ситуация, когда результаты предыдущей команды из такой конструкции используются в команде последующей. В этом случае ошибка исполнения любой составляющей команды, кроме последней, делает невозможным продолжение работы всей конструкции. Что само по себе было бы ещё полбеды — однако в некоторых ситуациях исполнение последующей команды возможно только при условии успешного завершения предыдущей.

Характерный пример — сборка программы из ее исходных текстов, включающая три стадии — конфигурирование, собственно компиляцию и установку собранных компонентов. Что обычно выполняется последовательностью из трёх команд:

```console
$ ./configure

$ make

$ make install
```

Ясно, что если конфигурирование завершилось ошибкой, то компиляция начаться не сможет и, соответственно, потом нечего будет устанавливать. И потому объединение их в последовательную конструкцию вида

```console
$ ./configure ; make ; make install
```

может оказаться нецелесообразным.

Однако для предотвращения таких ситуаций в конструкции из взаимосвязанных команд существует другой оператор, обозначаемый удвоенным символом амперсанда — &&. Он указывает, что последующая команда конструкции должна исполняться только в том случае, если предыдущая завершилась успешно:

```console
$ ./configure && make && make install
```

На практике обе приведённые в качестве примера конструкции дадут один и тот же результат — разумеется, если все составляющие их команды будут выполнены без ошибок. Однако в ряде иных случаев различие между этими конструкциями может быть существенным.

Впрочем, предусмотрена и командная конструкция, в которой последующей команде предписано исполняться в том и только в том случае, если предыдущая команда завершилась неудачно. Она имеет вид

```console
$ command1 || command2
```

и может служить, в частности, для вывода сообщений об ошибках.

### Перенаправление

Следующая командная конструкция — это так называемое перенаправление ввода/вывода. Чтобы понять,что это такое, нужно помнить две вещи:

1. любая команда получает данные для своей работы (например, список опций и аргументов) со стандартного устройства ввода (которым в первом приближении будем считать клавиатуру), а результаты своей работы представляет на стандартном устройстве вывода (коим договоримся считать экран монитора);

2. POSIX-системах любое устройство — не более чем имя специального файла, именуемого файлом устройства.

Таким образом, ничто не запрещает нам подменить специальный файл устройства ввода или устройства вывода любым иным файлом (например, обычным текстовым). Откуда и будут в этом случае браться входные данные или куда будет записываться вывод команды.

Перенаправление вывода команды обозначается следующим образом:

```console
$ command > filename
```

или

```console
$ command >> filename
```

В первом случае (одиночный символ `>`) вывод команды command образует содержимое нового файла с именем `filename`, не появляясь на экране. Или, если файл с этим именем существовал ранее, то его содержимое подменяется выходным потоком команды (точно также, как при копировании одного файла в другой, уже существующий). Почему такое перенаправление называется замещающим (или перенаправлением в режиме замещёния).

Во втором же случае (двойной символ `>>`) происходит добавление вывода команды `command` в конец существующего файла `filename` (при отсутствии же его в большинстве случаев просто образуется новый файл). И потому это называется присоединяющим перенаправлением, или перенаправлением в режиме присоединения.

Перенаправление ввода выглядит так:

```console
$ command < filename
```

Простейший случай перенаправления вывода — сохранение результата исполнения команды в обычном текстовом файле. Например, конструкция

```console
$ ls dir1 > list
```

создаст файл, содержанием которого будет список файлов каталога `dir1`. А в результате выполнения конструкции

```console
$ ls dir2 >> list
```

к этому списку добавится и содержимое каталога `dir2`.

При перенаправлении ввода команда получает данные для своей работы из входящего в командную конструкцию файла. Например, конструкция

```console
$ sort < list
```

выведет на экран строки файла `list`, отсортированных в порядке возрастания значения ASCII-кода первого символа, а конструкция

```console
$ sort -r < list
```

осуществит сортировку строк того же файла в порядке, обратном алфавитному (вернее, обратном порядку кодов символов, но это нас в данном случае не волнует).

В одной конструкции могут сочетаться перенаправления ввода и вывода, как в режиме замещёния, так и в режиме присоединения. Так, конструкция

```console
$ sort -r < list > list_r
```

не только выполнит сортировку строк файла `list` (это — назначение команды `sort`) в обратном алфавитному порядке (что предписывается опцией `-r`, происходящей в данном случае от reverce), но и запишет ее результаты в новый файл `list_r`, а конструкция

```console
$ sort -r < list >> list
```

добавит по-новому отсортированный список в конец существующего файла `list`.

### Конвейеры

Возможности построения командных конструкций не ограничиваются перенаправлением ввода/вывода: результаты работы одной команды могут быть переданы для обработки другой команде. Это достигается благодаря механизму программных каналов (pipe) или конвейеров — последний термин лучше отражает существо дела.

При конвейеризации команд стандартный вывод первой команды передается не в файл, а на стандартный ввод следующей команды. Простой пример такой операции — просмотр списка файлов:

```console
$ ls -l | less
```

Перенаправление вывода команды `ls`, то есть списка файлов, который при использовании полного формата записи (опция `-l`) может занимать многие экраны, на ввод команды less позволяет просматривать результат с ее помощью постранично или построчно в обоих направлениях.

Конвейеризация команд может быть сколь угодно длинной. Возможно также объединение конвейеризации команд и перенаправления в одной конструкции. Кроме того, команды в конструкции могут быть сгруппированы с тем, чтобы они выполнялись как единое целое. Для этого группа команд разделяется символами `;` и пробелами, как при последовательном выполнении команд, и заключается в фигурные скобки. Так, если нам требуется перенаправить вывод нескольких команд в один и тот же файл, вместо неуклюжей последовательности типа

```console
$ command1 > file ; command2 >> file ; ... ; commandN >> file
```

можно прибегнут к более изящной конструкции:

```console
$ { command1 ; command2 ; ... ; commandN } > file
```

Как и многие из ранее приведённых примеров, этот может показаться надуманным. Однако представьте, что вам нужно создать полный список файлов вашего домашнего каталога, разбитый по подкаталогам, да ещё и с комментариями, в каком подкаталоге что находится. Конечно, можно вывести состав каждого подкаталога командой `ls`, слить их воедино командой `cat` (она предназначена, в частности, и для объединения — конкатенации, — файлов, и речь о ней будет позже), загрузить получившееся хозяйство в текстовый редактор или ворд-процессор, где добавить необходимые словеса. А можно — обойтись единой конструкцией:

```console
$ { echo "List of my files" ;  > echo "My text" ;
        ls text/* ;  > echo "My images" ;
        ls images/* ;  > echo "My audio" ;
        ls audio/* ;  > echo "My video" ;
        ls video/* } > my-filelist
```

И в результате получить файл такого (условно) содержания, которое мы для разнообразия просмотрим с помощью только что упомянутой команды `cat` (благо и для просмотра содержимого файлов она также пригодна):

```console
$ cat my-filelist

List of my files
My text
text/text1.txt text/text2.txt
My images
images/img1.tif images/img2.tif
My audio
audio/sing1.mp3 audio/sing2.mp3
My video
video/film1.avi video/film2.avi
```

### Понятие о фильтрах

С понятием командных конструкций тесно связано понятие программ-фильтров. Это — команды, способные принимать на свой ввод данные с вывода других команд, производить над ними некоторые действия и перенаправлять свой вывод (то есть результат модификации полученных данных) в файлы или далее по конвейеру — другой команде.

Программы-фильтры — очень эффективное средство обработки текстов, и в своё время мы к ним вернемся для подробного изучения. Пока же важно отметить, что в качестве фильтров могут работать не все команды. Например, команды `find` или `grep` фильтруют имена файлов или фрагменты их содержимого, а команда `ls` фильтром не является.

### Сценарии оболочки

Наш затянувшийся разговор о командах и командном интерфейсе подходит к концу. И в заключение этого раздела — ещё немного терпения. Потому что было бы несправедливо не уделить чуть-чуть места тому, что придает командному интерфейсу POSIX-систем его несравненную гибкость и универсальность. Заодно способствуя закоснению пользователя в смертном грехе лености. Итак — слово о сценариях оболочки.

В самом начале я обмолвился, что шелл — это не просто среда для ввода единичных команд и командных конструкций, но и ещё интерпретатор собственного языка программирования. Так вот, сценарии оболочки, именуемые также скриптами, — это и есть программы, написанные на этом языке.

Только не заподозрите меня в гнусном намерении учить вас программерству. Господь борони, и в мыслях не держал (тем паче, что и сам-то этим ремеслом не владею в должной для обучения других степени). Нет, просто на последующих страницах нам то и дело придётся рассматривать кое-какие примеры готовых сценариев, а подчас и пытаться создавать их собственноручно. Ибо занятие это в элементарном исполнении навыков программирования не требует вообще.

В самом простом случае сценарий — это просто одна или несколько команд или (и) командных конструкций с необходимыми опциями и аргументами, сохраненные в виде обычного именованного текстового файла. И предназначены они в первую очередь для автоматизации часто исполняемых рутинных операций, в частности, ввода длинных последовательностей в командной строке.

Создание пользовательского сценария — просто, как правда. Для этого всего и нужно:

* создать командную конструкцию, достойную увековечивания;
* поместить ее в простой текстовый файл;
* по потребности и желанию снабдить комментариями;
* тем или иным способом запустить файл на исполнение.

С принципами создания команд и командных конструкций мы в первом приближении разобрались раньше. А вот способов помещёния их в файл существует множество. Можно просто ввести (или вызвать из буфера истории) нужную команду и оформить ее как аргумент команды echo, вывод которой перенаправить в файл:

```console
$ echo "cp -rf workdir backupdir" > mybackup
```

Таким образом мы получили простейший скрипт для копирования файлов из рабочего каталога в каталог для резервного хранения данных, что впредь и будем проделывать регулярно (не так ли?).

Аналогичную процедуру можно выполнить с помощью команды `cat` — она, оказывается, способна не только к объединению файлов и выводу их содержимого, но и к вводу в файл каких-либо данных. Делается это так. Вызываем `cat` с перенаправлением ее вывода в файл:

```console
$ cat > myarchive
```

и нажимаем `Enter`. После этого команда остается в ожидании ввода данных для помещёния их в новообразованный файл. Не обманем ее ожиданий и проделаем это. причём можно не жаться и выполнить ввод в несколько строк, например:

```console
cd $HOME/archivedir tar cf archive.tar

        ../workdir gzip archive.tar
```

Завершив ввод тела скрипта, все той же клавишей `Enter` открываем новую строку и набираем комбинацию `Control+D`, выдающую символ окончания файла.

В результате получаем сценарий для архивирования в специально предназначенном для этого каталоге archivedir наших рабочих данных (командой tar), а заодно и их компрессии (командой `gzip`) — в Unix, в отличие от DOS/Windows, архивирование и компрессия обычно рассматриваются как разные процедуры.

Наконец, сценарий можно создать в любом текстовом редакторе. но это не так интересно — по крайней мере, пока. Да и стоит ли вызывать редактор ради двух-трёх строк?

Комментариями в шелл-сценариях считаются любые строки, начинающиеся с символа решетки (`#`) — они не учитываются интерпретатором и не принимаются к исполнению. Хотя комментарий может быть начат и внутри строки — важно только, что между символом `#` и концом её больше ничего не было бы. Ясно, что комментарии — элемент для скрипта не обязательный, но очень желательный. Хотя бы для того, чтобы не забыть, ради чего этот сценарий создавался.

Но одна строка, начинающаяся символом решётки, в сценарии практически обязательна. И должна она быть первой и выглядеть следующим образом:

```bash
#!/path/shell_name
```

В данном случае восклицательный знак подчеркивает, что предваряющий его символ решетки (`#`) — не комментарий, а указание (т.н. sha-bang) на точный абсолютный путь к исполняемому файлу оболочки, для которой наш сценарий предназначен, например,

```bash
#!/bin/sh
```

для POSIX-шелла, или

```bash
#!/bin/bash
```

для оболочки Bash. Здесь следует подчеркнуть, что шелл, для которого предназначается сценарий, отнюдь не обязан совпадать с командной оболочкой пользователя. И полноты картины для замечу, что указание точного имени интерпретатора требуется не только для шелл-скриптов, но и для программ на любых языках сценариев (типа Perl или Python).

Так что по хорошему в обоих приведенных выше примерах ввод команд сценария следовало бы предварить строкой sha-bang. Конечно, отсутствие имени командной оболочки в явном виде обычно не помешает исполнению шелл-сценария: для этого будет вызван системный командный интерпретатор по умолчанию — в Mint `/bin/dash`. Однако если сценарий предназначен для другой командной оболочки, то без sha-bang он может исполняться неправильно (или не исполняться вообще).

Теперь остается только выполнить наш сценарий. Сделать это можно разными способами. Самый напрашивающийся — непосредственно вызвать требуемый шелл как обычную команду, снабдив его аргументом — именем сценария (предположим, что он находится в текущем каталоге):

```console
$ bash scriptname
```

Далее, для вызова скриптов существует специальная встроенная команда оболочки, обозначаемая символом точки. Используется она аналогично:

```console
$ . ./scriptname
```

с тем только исключением, что тут требуется указание текущего каталога в явном виде (что и символизируется `./`).

Однако наиболее употребимый способ запуска сценариев — это присвоение его файлу так называемого атрибута исполнения. Эта процедура волшебным образом превращает невзрачный текстовый файлишко во всамделишную (хотя и очень простую) программу.

Так вот, после присвоения нашему сценарию бита исполнения запустить его можно точно также, как любую другую команду — просто из командной строки:

```console
$ ./scriptname
```

Опять же — в предположении, что сценарий находится в текущем каталоге (`./`), иначе потребуется указание полного пути к нему. Что, понятно, лениво, но решается раз и навсегда: все сценарии помещаются в специально отведенный для этого каталог (например, `$HOME/bin`), который и добавляется в качестве ещё одного значения переменной `PATH` данного пользователя.

### Понятие о функциях

И уж совсем в заключение этого раздела осталось сказать пару слов о функциях командной оболочки. Это — такая же последовательность команд (или даже просто одиночная команда), как и сценарий, но — не вынесенная в отдельный исполняемый файл, а помещённая в тело другого скрипта. В коем она опознаётся по имени, и может быть выполнена неоднократно в ходе работы этого скрипта.

Главное отличие функции от сценария — в том, что она выполняется в том же процессе (и, соответственно, экземпляре шелла), что и заключающий её сценарий. Тогда как для каждого скрипта, вызываемого из другого сценария, создаётся отдельный процесс, порождающий собственный экземпляр шелла. Это может быть важным, если в сценарии определяются некоторые переменные, которые имеют силу только в нём самом.

Функции не обязательно помещаются внутрь сценария — их можно собрать в некоторые отдельные файлы, которые именуются библиотеками функций и могут быть использованы по мере надобности.

Ранее на протяжении всего повествования неоднократно упоминались (и будут упоминаться впредь) системные библиотеки, в частности, главная библиотека `glibc`. Так вот, это — точно такие же сборники функций, правда, не командной оболочки, а языка Си, и, соответственно, хранящиеся не в виде текстовых файлов, а в бинарном, откомпилированном, виде.

### Настройка шелла

Во всех дистрибутивах Linux в качестве пользовательской командной оболочки по умолчанию выступает Bash, и Mint здесь не исключение. Так что, хотя автор этих строк не является ни её любителем, ни, тем более, знатоком, совсем обойти её вниманиемне мог. Так что ниже даётся мини-очерк настройки этого шелла.

Оболочка Bash поддерживает все интерактивные возможности, столь важные для пользователя, как то: автодополнение для команд и путей к файлам, историю оных (включая средства инкрементного поиска), мощные возможности навигации и редактирования командной строки.

Важно, что существует дополнительный пакет bash-completion: установка его обогащает базовую оболочку множеством опциональных средств настройки автодополнения (в том числе и для командных аргументов). Правда, чтобы эта дополненная оболочка была по настоящему удобной и функциональной, нужно приложить некоторые усилия по её настройке, чем мы сейчас и займёмся.

Схема настройки bash предусматривает наличие пары файлов `/etc/profile` и `/etc/bashrc` (для логин-шелла и просто интерактивного его экземпляра), а также соответствующих им пользовательских конфигов — `~/.bash_profile` и `~/.bashrc`. При авторизации первым в любом случае считывается общесистемный профильный файл `/etc/profile`, вслед за ним — пользовательский профильный файл `~/.bash_profile`, после чего происходит обращение к ~/.bashrc. Файл `/etc/profile` может занимать особое положение — в него часто помещают переменные окружения (например, локально-зависимые), которые должны быть общими для всех пользователей данной системы. Пользовательские же настройки определяются в файлах `~/.bash_profile` и `~/.bashrc`. Обычно в `~/.bash_profile` определяются переменные окружения, которые должны действовать для всех дочерних процессов, а в `~/.bashrc` — параметры, всегда требуемые в интерактивном режиме (например, псевдонимы).

Редактирование командной строки в bash обеспечивается отдельным пакетом — библиотекой функций `readline`. Она имеет собственные конфигурационные файлы, общесистемный `/etc/inputrc` и пользовательский `~/.inputrc`.

Впрочем, в большинстве современных дистрибутивов Linux, ориентированных на графический режим и, следовательно, использование эмулятора терминала с интерактивным шеллом, не являющимся, тем не менее, шеллом пользовательским (login shell), `~/.bash_profile` играет сугубо служебную роль, и содержимое его сводится к отработке файла `~/.bashrc`:

```bash
# include .bashrc if it existsif [-f ~/.bashrc]; then
. ~/.bashrc
fi# set PATH so it includes user's private bin if it existsif [-d ~/bin] ; then
PATH=~/bin:"${PATH}"
fi
```

Именно в `~/.bashrc` и выполняются при этом все пользовательские настройки.

Большинство настроек Bash по умолчанию разумны, и потому наличные в данном дистрибутиве файлы вполне могут быть взяты за основу. Однако путём некоторых несложных действий их можно дополнить, увеличив удобство интерактивного использования командной оболочки.

По умолчанию в Bash автодополнение клавишей табулятора не работает, например, в аргументах многих команд, таких, как `sudo` или `man`.

Решается эта задача очень просто: достаточно файл `~/.bashrc` внести следующие строки:

```bash
# enable bash completion in interactive shells
if [-f /etc/bash_completion]; then
 . /etc/bash_completion
fi
```

После этого автодополнение будет работать буквально везде, где только можно себе представить, например, после набора dpkg --sea и нажатия табулятора получится dpkg --search.

Если в файл /etc/inpurc (или в ~/inpurc) добавить такие строки:

```
"e[A": history-search-backward
"e[B": history-search-forward
```

то набор части команды, например, `cd /`, и последующий перебор стрелками `<Up>` и `<Down>` истории команд повлечёт извеление из буфера истории только тех из них, которые начинаются на `cd /`.
